## Принципи, реалізовані в проекті:

### 1. KISS (Keep It Simple, Stupid)
Принцип KISS забезпечується шляхом чіткого розподілу відповідальності між класами, що робить код простішим для розуміння та підтримки:
- Клас `Product` відповідає за дані про продукт, його ціну та кількість (`./lab1/Product.cs`).
- Клас `Warehouse` керує списком продуктів та операціями з ними (`./lab1/Warehouse.cs`).
- Клас `Reporting` генерує звіти (`./lab1/Reporting.cs`).

### 2. DRY (Don't Repeat Yourself)
Принцип DRY реалізовано наступним чином:
- `Product` містить логіку для роботи з цінами та кількістю товарів, уникаючи дублювання коду (`./lab1/Product.cs`).
- `Warehouse` обробляє список продуктів та операції з додавання, видалення та пошуку (`./lab1/Warehouse.cs`).
- `Reporting` централізує логіку створення звітів (`./lab1/Reporting.cs`).

### 3. Програмування на рівні інтерфейсів, а не реалізацій
Принцип програмування на рівні інтерфейсів реалізовано через:
- `Reporting` працює з `IProductManager`, а не з конкретною реалізацією `Warehouse`, що дозволяє змінювати реалізацію складу без зміни класу звітності (`./lab1/Reporting.cs`).

### 4. S - Принцип єдиної відповідальності (SRP)
- `Product` відповідає лише за збереження та операції над даними про продукт (`./lab1/Product.cs`).
- `Warehouse` керує списком продуктів, займається додаванням, видаленням та пошуком (`./lab1/Warehouse.cs`).
- `Reporting` генерує звіти, не змішуючи інші функції (`./lab1/Reporting.cs`).

### 5. D - Принцип інверсії залежностей (DIP)
- `Reporting` залежить від абстракції (`IProductManager`), а не від конкретної реалізації складу (`Warehouse`), що забезпечує гнучкість (`./lab1/Reporting.cs`).

### 6. O - Принцип відкритості/закритості (OCP)
- `Warehouse` можна розширювати, додаючи нові методи через інтерфейс `IProductManager`, без зміни основної логіки (`./lab1/IProductManager.cs`).
- `Reporting` може бути розширений новими типами звітів без модифікації основної логіки (`./lab1/Reporting.cs`).

### 7. L - Принцип підстановки Лісков (LSP)
- `Warehouse` реалізує `IProductManager` і може бути замінений будь-яким іншим класом, що реалізує цей інтерфейс, не порушуючи коректності програми (`./lab1/Warehouse.cs`).

### 8. I - Принцип розділення інтерфейсів (ISP)
- `IProductManager` відповідає лише за операції з продуктами, а `IReporting` — тільки за створення звітів, що запобігає зайвій залежності (`./lab1/IProductManager.cs`, `./lab1/IReporting.cs`).

### 9. Композиція замість наслідування
- `Warehouse` реалізує `IProductManager`, що дозволяє змінювати реалізацію без використання наслідування, зберігаючи незалежність інших класів (`./lab1/Warehouse.cs`).